// #############################################################################
//! \file \cs30_f2837x\F2837xS_examples_Cpu1\cla_vmaxfloat\cpu01\vmaxfloat.cla
//!
//! \brief  Vector Maximum
//! \author Tri Thai
//! \date   August 2, 2013
//! 
//
//  Group: 			C2000
//  Target Family:	F2837x
//
// (C)Copyright 2013, Texas Instruments, Inc.
// #############################################################################
//$TI Release: PACKAGE NAME $
//$Release Date: PACKAGE RELEASE DATE $
// #############################################################################

//*****************************************************************************
// includes
//*****************************************************************************
#include "F2837xS_Cla_defines.h"
#include "F2837xS_device.h"     // Headerfile Include File
//#include "F2837xS_gpio.h"   // Examples Include File

#include "VariblesRef.h"
#include "Cla_data.h"
#include "CLAmath.h"
#include "CoreCtrl.h"
#include "DCLCLA.h"
#include "DCL.h"
#include "MarcoDefine.h"
/*
7.CMPB  7.CMPA  示波器4/2管      示波器3/1管        结论
                            受控于CMPB   受控于CMPA
0       0       高                   低                           4管导通,正常
3125    0       低                   低                           3,4管关断,正常
3125    3125    低                   高                           3管导通,正常
0       3125    低                   高                           3管导通,4管关断,竞争
1000    3125    低                   高
0       3124    高                   低
3122    3124    低                   98.72%
2950    3124    0.64%       94.72%
1       3124    47.60%      47.68%
3000    125     1.60%       1.60%
3124    125     低                   1.60%
2000    1125    33.60%      33.60%
1500    1625    47.70%      47.70%
1462    1225    50.96%      36.80%
3045    0       0.30%       低
2       0       99.04%      低
125     3000    47.70%      47.70%
1       1       高                   低
结论:
A为T1PR,占空比为100%
B为0,占空比为100%
AB相加和大于T1PR,B优先表现
*/
//#define EPwmRegsAQCSFRCclear 0x00000000
//#define EPwmRegsAQCSFRC   0x00050000



//float VoltInF,CurrInF;
void CurrDirPwmA(float32 data)
{

//    if(PWMcurrDirFlagA){
//        if(VoltInAF > 15){
//            *EPwm3RegsCMPB = T1PR*(1-ESC_DutyDataA);   //2
//            *EPwm3RegsCMPA = T1PR*ESC_DutyDataA;   //1
//            *EPwm4RegsCMPB = T1PR*1;   //4
//            *EPwm4RegsCMPA = T1PR*1;   //3
//        }else if(VoltInAF < (-15)){
//            *EPwm3RegsCMPB = T1PR*1;   //2
//            *EPwm3RegsCMPA = T1PR*1;   //1
//            *EPwm4RegsCMPB = T1PR*(1-ESC_DutyDataA);   //4
//            *EPwm4RegsCMPA = T1PR*ESC_DutyDataA;   //3
//        }else{
//            if(Esc_VoltPhaseA < PI){    //从上往下 3 1 2 4管
//                if(flagA){    //电压正 且电流正,应该是4>1 = 3<2
//                    *EPwm3RegsCMPB = (1-T1PRmulESC_DutyDataAsubnegCurCompPerc); //2管
//                    *EPwm3RegsCMPA = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //1管
//                    *EPwm4RegsCMPB = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //4管
//                    *EPwm4RegsCMPA = (1-T1PRmulESC_DutyDataAaddnegCurCompPerc); //3管
//                }else{       //电压正 且电流--,应该是4<1 = 3>2
//                    *EPwm3RegsCMPB = (1-T1PRmulESC_DutyDataAaddnegCurCompPerc); //2管
//                    *EPwm3RegsCMPA = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //1管
//                    *EPwm4RegsCMPB = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //4管
//                    *EPwm4RegsCMPA = (1-T1PRmulESC_DutyDataAsubnegCurCompPerc); //3管
//                }
//            }else{ //电压为负半波
//                if(flagA){    //电压-- 且电流+,应该是4<1 = 3>2
//                    *EPwm3RegsCMPB = (1-T1PRmulESC_DutyDataAaddnegCurCompPerc); //2管
//                    *EPwm3RegsCMPA = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //1管
//                    *EPwm4RegsCMPB = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //4管
//                    *EPwm4RegsCMPA = (1-T1PRmulESC_DutyDataAsubnegCurCompPerc); //3管
//                }else{       //电压-- 且电流--,应该是4>1 = 3<2
//                    *EPwm3RegsCMPB = (1-T1PRmulESC_DutyDataAsubnegCurCompPerc); //2管
//                    *EPwm3RegsCMPA = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //1管
//                    *EPwm4RegsCMPB = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //4管
//                    *EPwm4RegsCMPA = (1-T1PRmulESC_DutyDataAaddnegCurCompPerc); //3管
//                }
//            }
//        }
//    }

//    if(VoltInAF >= 3){
//        CLASET_DBG_IO1(1);
//    }

//    dbg_claWave[0]=data;
//    int flagA=data>0?1:0;   //A;
//    if(VoltInAF >= 25){                 //电压反向了,实际上是电压负半轴
//        *EPwm8RegsCMPB = 1<<16;                 //2,常通,续流管
//        *EPwm8RegsCMPA = 3124<<16;              //1,常通续流管        //1,低
//        *EPwm7RegsCMPB = T1PRmulESC_DutyDataA;  //4
//        *EPwm7RegsCMPA = T1PRmulESC_DutyDataA;  //3,buck管
//        *EPwm8RegsAQCSFRC = EPwmRegsAQCSFRC;
//        *EPwm7RegsAQCSFRC = EPwmRegsAQCSFRCclear;
//   }else if(VoltInAF <= (-25)){         //实际上是电压正半轴
//        *EPwm8RegsCMPB = T1PRmulESC_DutyDataA;  //2
//        *EPwm8RegsCMPA = T1PRmulESC_DutyDataA;  //1,buck管
//        *EPwm7RegsCMPB = 1<<16;                 //4,常通,续流管
//        *EPwm7RegsCMPA = 3124<<16;              //3,常通,续流管       //3,常关
//        *EPwm8RegsAQCSFRC = EPwmRegsAQCSFRCclear;
//        *EPwm7RegsAQCSFRC = EPwmRegsAQCSFRC;
//    }else{
//        if((VoltInAF > 0)&&(VoltInAF < 25)){
//            if(flagA){
//                *EPwm8RegsCMPA = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //1管
//                *EPwm8RegsCMPB = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //2管
//                *EPwm7RegsCMPA = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //3管
//                *EPwm7RegsCMPB = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //4管
//            }else{
//                *EPwm8RegsCMPA = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //1管
//                *EPwm8RegsCMPB = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //2管
//                *EPwm7RegsCMPA = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //3管
//                *EPwm7RegsCMPB = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //4管
//            }
//        }else if((VoltInAF < 0)&&(VoltInAF > (-25))){
//            if(flagA){
//                *EPwm8RegsCMPA = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //1管
//                *EPwm8RegsCMPB = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //2管
//                *EPwm7RegsCMPA = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //3管
//                *EPwm7RegsCMPB = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //4管
//            }else{
//                *EPwm8RegsCMPA = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //1管
//                *EPwm8RegsCMPB = (T1PRmulESC_DutyDataAaddnegCurCompPerc); //2管
//                *EPwm7RegsCMPA = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //3管
//                *EPwm7RegsCMPB = (T1PRmulESC_DutyDataAsubnegCurCompPerc); //4管
//            }
//        }
////        __asm(" MEALLOW");
//        *EPwm8RegsAQCSFRC = EPwmRegsAQCSFRCclear;
//        *EPwm7RegsAQCSFRC = EPwmRegsAQCSFRCclear;
////        __asm(" MEDIS");
//
//    }

}
//Uint16 flagB;
void CurrDirPwmB(float32 data)
{
//////    int flagB=data>0?1:0;   //B;
////    flagB=data>0?1:0;
////    if(PWMcurrDirFlagB){
////        if(Esc_VoltPhaseB < PI){    //从上往下 3 1 2 4管
////            if(flagB){    //电压正 且电流正,应该是4>1 = 3<2
////                *EPwm5RegsCMPB = (T1PRmulESC_DutyDataBsubnegCurCompPerc);//1管set
////                *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBaddnegCurCompPerc);//4管clear
////            }else{       //电压正 且电流--,应该是4<1 = 3>2
////                *EPwm5RegsCMPB = (T1PRmulESC_DutyDataBaddnegCurCompPerc);//
////                *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBsubnegCurCompPerc);//
////            }
////        }else{ //电压为负半波
////            if(flagB){    //电压-- 且电流+,应该是4<1 = 3>2
////                *EPwm5RegsCMPB = (T1PRmulESC_DutyDataBsubnegCurCompPerc);
////                *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBaddnegCurCompPerc);
////            }else{       //电压-- 且电流--,应该是4>1 = 3<2
////                *EPwm5RegsCMPB = (T1PRmulESC_DutyDataBaddnegCurCompPerc); //1管
////                *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBsubnegCurCompPerc); //4管
////            }
////        }
////    }
//    int flagB=data>0?1:0;   //B;
//    if(PWMcurrDirFlagB){
//        if(VoltInBF > 15){
//            *EPwm5RegsCMPB = T1PR*(1-ESC_DutyDataB);   //2
//            *EPwm5RegsCMPA = T1PR*ESC_DutyDataB;   //1
//            *EPwm6RegsCMPB = T1PR*1;   //4
//            *EPwm6RegsCMPA = T1PR*1;   //3
//        }else if(VoltInBF < (-15)){
//            *EPwm5RegsCMPB = T1PR*1;   //2
//            *EPwm5RegsCMPA = T1PR*1;   //1
//            *EPwm6RegsCMPB = T1PR*(1-ESC_DutyDataB);   //4
//            *EPwm6RegsCMPA = T1PR*ESC_DutyDataB;   //3
//        }else{
//            if(Esc_VoltPhaseB < PI){    //从上往下 3 1 2 4管
//                if(flagB){    //电压正 且电流正,应该是4>1 = 3<2
//                    *EPwm5RegsCMPB = (1-T1PRmulESC_DutyDataBsubnegCurCompPerc); //2管
//                    *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBsubnegCurCompPerc); //1管
//                    *EPwm6RegsCMPB = (T1PRmulESC_DutyDataBaddnegCurCompPerc); //4管
//                    *EPwm6RegsCMPA = (1-T1PRmulESC_DutyDataBaddnegCurCompPerc); //3管
//                }else{       //电压正 且电流--,应该是4<1 = 3>2
//                    *EPwm5RegsCMPB = (1-T1PRmulESC_DutyDataBaddnegCurCompPerc); //2管
//                    *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBaddnegCurCompPerc); //1管
//                    *EPwm6RegsCMPB = (T1PRmulESC_DutyDataBsubnegCurCompPerc); //4管
//                    *EPwm6RegsCMPA = (1-T1PRmulESC_DutyDataBsubnegCurCompPerc); //3管
//                }
//            }else{ //电压为负半波
//                if(flagB){    //电压-- 且电流+,应该是4<1 = 3>2
//                    *EPwm5RegsCMPB = (1-T1PRmulESC_DutyDataBaddnegCurCompPerc); //2管
//                    *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBaddnegCurCompPerc); //1管
//                    *EPwm6RegsCMPB = (T1PRmulESC_DutyDataBsubnegCurCompPerc); //4管
//                    *EPwm6RegsCMPA = (1-T1PRmulESC_DutyDataBsubnegCurCompPerc); //3管
//                }else{       //电压-- 且电流--,应该是4>1 = 3<2
//                    *EPwm5RegsCMPB = (1-T1PRmulESC_DutyDataBsubnegCurCompPerc); //2管
//                    *EPwm5RegsCMPA = (T1PRmulESC_DutyDataBsubnegCurCompPerc); //1管
//                    *EPwm6RegsCMPB = (T1PRmulESC_DutyDataBaddnegCurCompPerc); //4管
//                    *EPwm6RegsCMPA = (1-T1PRmulESC_DutyDataBaddnegCurCompPerc); //3管
//                }
//            }
//        }
//    }
}

void CurrDirPwmC(float32 data)
{
////    int flagC=data>0?1:0;   //C;
////    if(PWMcurrDirFlagC){
////        if(Esc_VoltPhaseC < PI){    //从上往下 3 1 2 4管
////            if(flagC){    //电压正 且电流正,应该是4>1 = 3<2
////                *EPwm6RegsCMPB = (T1PRmulESC_DutyDataCsubnegCurCompPerc); //1管set
////                *EPwm6RegsCMPA = (T1PRmulESC_DutyDataCaddnegCurCompPerc);//4管clear
////            }else{       //电压正 且电流--,应该是4<1 = 3>2
////                *EPwm6RegsCMPB = (T1PRmulESC_DutyDataCaddnegCurCompPerc);
////                *EPwm6RegsCMPA = (T1PRmulESC_DutyDataCsubnegCurCompPerc);//(quarterPeriod*(sa+1));//PwmVa;
////            }
////        }else{ //电压为负半波
////            if(flagC){    //电压-- 且电流+,应该是4<1 = 3>2
////                *EPwm6RegsCMPB = (T1PRmulESC_DutyDataCsubnegCurCompPerc);
////                *EPwm6RegsCMPA = (T1PRmulESC_DutyDataCaddnegCurCompPerc);//(quarterPeriod*(sa+1));//PwmVa;
////            }else{       //电压-- 且电流--,应该是4>1 = 3<2
////                *EPwm6RegsCMPB = (T1PRmulESC_DutyDataCaddnegCurCompPerc); //1管
////                *EPwm6RegsCMPA = (T1PRmulESC_DutyDataCsubnegCurCompPerc);                    //4管
////            }
////        }
////    }
//    int flagC=data>0?1:0;   //C;
//    if(PWMcurrDirFlagC){
//        if(VoltInCF > 15){
//            *EPwm7RegsCMPB = T1PR*(1-ESC_DutyDataC);   //2
//            *EPwm7RegsCMPA = T1PR*ESC_DutyDataC;   //1
//            *EPwm8RegsCMPB = T1PR*1;   //4
//            *EPwm8RegsCMPA = T1PR*1;   //3
//        }else if(VoltInCF < (-15)){
//            *EPwm7RegsCMPB = T1PR*1;   //2
//            *EPwm7RegsCMPA = T1PR*1;   //1
//            *EPwm8RegsCMPB = T1PR*(1-ESC_DutyDataC);   //4
//            *EPwm8RegsCMPA = T1PR*ESC_DutyDataC;   //3
//        }else{
//            if(Esc_VoltPhaseC < PI){    //从上往下 3 1 2 4管
//                if(flagC){    //电压正 且电流正,应该是4>1 = 3<2
//                    *EPwm7RegsCMPB = (1-T1PRmulESC_DutyDataCsubnegCurCompPerc); //2管
//                    *EPwm7RegsCMPA = (T1PRmulESC_DutyDataCsubnegCurCompPerc); //1管
//                    *EPwm8RegsCMPB = (T1PRmulESC_DutyDataCaddnegCurCompPerc); //4管
//                    *EPwm8RegsCMPA = (1-T1PRmulESC_DutyDataCaddnegCurCompPerc); //3管
//                }else{       //电压正 且电流--,应该是4<1 = 3>2
//                    *EPwm7RegsCMPB = (1-T1PRmulESC_DutyDataCaddnegCurCompPerc); //2管
//                    *EPwm7RegsCMPA = (T1PRmulESC_DutyDataCaddnegCurCompPerc); //1管
//                    *EPwm8RegsCMPB = (T1PRmulESC_DutyDataCsubnegCurCompPerc); //4管
//                    *EPwm8RegsCMPA = (1-T1PRmulESC_DutyDataCsubnegCurCompPerc); //3管
//                }
//            }else{ //电压为负半波
//                if(flagC){    //电压-- 且电流+,应该是4<1 = 3>2
//                    *EPwm7RegsCMPB = (1-T1PRmulESC_DutyDataCaddnegCurCompPerc); //2管
//                    *EPwm7RegsCMPA = (T1PRmulESC_DutyDataCaddnegCurCompPerc); //1管
//                    *EPwm8RegsCMPB = (T1PRmulESC_DutyDataCsubnegCurCompPerc); //4管
//                    *EPwm8RegsCMPA = (1-T1PRmulESC_DutyDataCsubnegCurCompPerc); //3管
//                }else{       //电压-- 且电流--,应该是4>1 = 3<2
//                    *EPwm7RegsCMPB = (1-T1PRmulESC_DutyDataCsubnegCurCompPerc); //2管
//                    *EPwm7RegsCMPA = (T1PRmulESC_DutyDataCsubnegCurCompPerc); //1管
//                    *EPwm8RegsCMPB = (T1PRmulESC_DutyDataCaddnegCurCompPerc); //4管
//                    *EPwm8RegsCMPA = (1-T1PRmulESC_DutyDataCaddnegCurCompPerc); //3管
//                }
//            }
//        }
//    }
}

__attribute__((interrupt)) void Cla1Task1 ( void )      //9组,6us
{
    float tmp;
////    CLASET_DBG_IO3(1);
////    if(mdebugen>=2)   __mdebugstop();
////    __mdebugstop();
////    PWMout();       //低16位
////    /*dbg_claWave[0]=*/tmp=((float)(*AdcaResultRegsADCRESULT14 & 0x0000ffff) - VirtulAD_loadCurrentA)*outputCurRatio;   //这个点的零飘是如何和之前的零飘下发参数对应起来的???
////    CurrDirPwmA(tmp);
////    dbg_claPwmReg[0] = (float )(*EPwm6RegsCMPA>>16);
////    dbg_claPwmReg[1] = (float )(*EPwm6RegsCMPB>>16);
////    CLASET_DBG_IO3(0);
//    point1=((float )(*AdcaResultRegsADCRESULT8  & 0x0000ffff) - VirtulAD_loadCurrentA)*outputCurRatioCurrA;
//    point2=((float )(*AdcaResultRegsADCRESULT10 & 0x0000ffff) - VirtulAD_loadCurrentA)*outputCurRatioCurrA;
////    dbg_claWave[2]= tmp = point1 + CLATestValue*((point2>0)?-fabsf(point1-point2):fabsf(point1-point2));
//    tmp = (point2-point1) * CLATestValue + point1;
////    if(mdebugen==4)   __mdebugstop();
//    CurrDirPwmA(tmp);

    tmp=((float )(*AdcaResultRegsADCRESULT8  & 0x0000ffff) - VirtulAD_loadCurrentA)*outputCurRatioCurrA;
    CurrDirPwmA(tmp);
}

// Task 2 : Vector max - brute force
__attribute__((interrupt)) void Cla1Task2 ( void )
{
    float tmp;
////    CLASET_DBG_IO1(1);
////    __mdebugstop();
//    //高16位
////    /*dbg_claWave[1]=*/tmp=((float)(*AdcaResultRegsADCRESULT15>>16) - VirtulAD_loadCurrentA)*outputCurRatio;
////    CurrDirPwmA(tmp);
////    dbg_claPwmReg[2] = (float )(*EPwm6RegsCMPA>>16);
////    dbg_claPwmReg[3] = (float )(*EPwm6RegsCMPB>>16);
////    CLASET_DBG_IO1(0);
//    point1=((float)(*AdcaResultRegsADCRESULT12 & 0x0000ffff) - VirtulAD_loadCurrentA)*outputCurRatioCurrA;
//    point2=((float)(*AdcaResultRegsADCRESULT14 & 0x0000ffff) - VirtulAD_loadCurrentA)*outputCurRatioCurrA;
////    dbg_claWave[5]= tmp = point1 + CLATestValue*((point2>0)?-fabsf(point1-point2):fabsf(point1-point2));
//    tmp = (point2-point1) * CLATestValue + point1;
//    CurrDirPwmA(tmp);
    tmp=((float )(*AdcaResultRegsADCRESULT10  & 0x0000ffff) - VirtulAD_loadCurrentA)*outputCurRatioCurrA;
    CurrDirPwmA(tmp);
}

//ADC预估值 = ((Y2-Y1)/过采样时间间隔 )*(想要得到切换点时间) + Y1
//ADC预估值 = (point2-point1)*AD_OVERSAMPLE_COEFFICIENT_K + Y1; AD_OVERSAMPLE_COEFFICIENT_K = 想要得到切换点时间/过采样时间间隔
__attribute__((interrupt)) void Cla1Task3 ( void )
{
    float tmp;
////    CLASET_DBG_IO3(1);
////    if(mdebugen==2)   __mdebugstop();
//    CLASET_DBG_IO2(1);
//
////    volatile long data=*AdccResultRegsADCRESULT12;
////    dbg_claPwmReg[1]=((float )(*AdccResultRegsADCRESULT15 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatio;
////    dbg_claPwmReg[0]=((float )(*AdccResultRegsADCRESULT13 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatio;
//
//    dbg_claWave[0]=point1=((float )(*AdccResultRegsADCRESULT8  & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatioCurrB;
//    dbg_claWave[1]=point2=((float )(*AdccResultRegsADCRESULT10 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatioCurrB;
////    dbg_claWave[2]= tmp = point1 + CLATestValue*((point2>0)?-fabsf(point1-point2):fabsf(point1-point2));
//    dbg_claWave[2]= tmp = (point2-point1) * CLATestValue + point1;
////    if(mdebugen==4)   __mdebugstop();
//    CurrDirPwmB(tmp);
//
//    dbg_claPwmReg[4] = (float )(*EPwm5RegsCMPA>>16);
//    dbg_claPwmReg[5] = (float )(*EPwm5RegsCMPB>>16);
////    CLASET_DBG_IO3(0);
//    CLASET_DBG_IO2(0);
////      float tmp;
////      tmp=((float)(*AdccResultRegsADCRESULT10 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatio;
////      CurrDirPwmB(tmp);
    tmp=((float )(*AdccResultRegsADCRESULT8  & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatioCurrB;
    CurrDirPwmB(tmp);

}
__attribute__((interrupt)) void Cla1Task4 ( void )
{
    float tmp;
////  CLASET_DBG_IO2(1);
////    if(mdebugen>=6)   __mdebugstop();
//    CLASET_DBG_IO3(1);
//
////   volatile long data=*AdccResultRegsADCRESULT14;
//
//    dbg_claWave[3]=point1=((float)(*AdccResultRegsADCRESULT12 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatioCurrB;
//    dbg_claWave[4]=point2=((float)(*AdccResultRegsADCRESULT14 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatioCurrB;
////    dbg_claWave[5]= tmp = point1 + CLATestValue*((point2>0)?-fabsf(point1-point2):fabsf(point1-point2));
//    dbg_claWave[5]= tmp = (point2-point1) * CLATestValue + point1;
//    CurrDirPwmB(tmp);
//    dbg_claPwmReg[6] = (float )(*EPwm5RegsCMPA>>16);
//    dbg_claPwmReg[7] = (float )(*EPwm5RegsCMPB>>16);
////  CLASET_DBG_IO2(0);
//    CLASET_DBG_IO3(0);
////    float tmp;
////    tmp=((float)(*AdccResultRegsADCRESULT14 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatio;
////    CurrDirPwmB(tmp);
    tmp=((float )(*AdccResultRegsADCRESULT10  & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatioCurrB;
    CurrDirPwmB(tmp);

}

//__attribute__((interrupt)) void Cla1Task3 ( void )
//{
////    float tmp;
//    CLASET_DBG_IO2(1);
//    if(mdebugen==2)
//        __mdebugstop();
//    dbg_claWave[2]=tmp=((float)(*AdccResultRegsADCRESULT14 & 0x0000ffff) - VirtulAD_loadCurrentB)*outputCurRatio;  //电流方向
//    CurrDirPwmB(tmp);
//
//    dbg_claPwmReg[0] =  (float )((*CLAtest2)&0x00000001);//EPwm5Regs.TBSTS.bit.CTRDIR;
//    dbg_claPwmReg[1] = (float )((*CLAtest1)&0x0000FFFF);//EPwm5Regs.TBCTR;
//    dbg_claPwmReg[2] = tempbuff;
//
//    dbg_claPwmReg[4] = (float )(*EPwm5RegsCMPA>>16);
//    dbg_claPwmReg[5] = (float )(*EPwm5RegsCMPB>>16);
//    CLASET_DBG_IO2(0);
//}
//
//__attribute__((interrupt)) void Cla1Task4 ( void )
//{
////    float tmp;
//    CLASET_DBG_IO1(1);
//    if(mdebugen==3)
//  __mdebugstop();
//    dbg_claWave[3]=tmp=((float)(*AdccResultRegsADCRESULT15>>16) - VirtulAD_loadCurrentB)*outputCurRatio;
//    CurrDirPwmB(tmp);
//    dbg_claPwmReg[6] = (float )(*EPwm5RegsCMPA>>16);
//    dbg_claPwmReg[7] = (float )(*EPwm5RegsCMPB>>16);
//    dbg_claWave[0] = (float )((*CLAtest2)&0x00000001);//EPwm5Regs.TBSTS.bit.CTRDIR;
//    dbg_claPwmReg[3] = (float )((*CLAtest1)&0x0000FFFF);//EPwm5Regs.TBCTR;
//    CLASET_DBG_IO1(0);
//}

__attribute__((interrupt)) void Cla1Task5 ( void )
{
    float tmp;
////    CLASET_DBG_IO2(1);
////  __mdebugstop();
////    /* dbg_claWave[4]=*/tmp=((float)(*AdcbResultRegsADCRESULT14 & 0x0000ffff) - VirtulAD_loadCurrentC)*outputCurRatio;
////    CurrDirPwmC(tmp);
////    CLASET_DBG_IO2(0);
//    point2=((float )(*AdcbResultRegsADCRESULT10 & 0x0000ffff) - VirtulAD_loadCurrentC)*outputCurRatioCurrC;
//    point1=((float )(*AdcbResultRegsADCRESULT8  & 0x0000ffff) - VirtulAD_loadCurrentC)*outputCurRatioCurrC;
////    dbg_claWave[2]= tmp = point1 + CLATestValue*((point2>0)?-fabsf(point1-point2):fabsf(point1-point2));
//    tmp = (point2-point1) * CLATestValue + point1;
//    if(mdebugen==4)   __mdebugstop();
//    CurrDirPwmC(tmp);
    tmp=((float )(*AdcbResultRegsADCRESULT8  & 0x0000ffff) - VirtulAD_loadCurrentC)*outputCurRatioCurrC;
    CurrDirPwmC(tmp);
}

__attribute__((interrupt)) void Cla1Task6 ( void )
{
    float tmp;
////    CLASET_DBG_IO1(1);
////  __mdebugstop();
////    /*dbg_claWave[5]=*/tmp=((float)(*AdcbResultRegsADCRESULT15>>16) - VirtulAD_loadCurrentC)*outputCurRatio;
////    CurrDirPwmC(tmp);
////    CLASET_DBG_IO1(0);
//    point2=((float)(*AdcbResultRegsADCRESULT14 & 0x0000ffff) - VirtulAD_loadCurrentC)*outputCurRatioCurrC;
//    point1=((float)(*AdcbResultRegsADCRESULT12 & 0x0000ffff) - VirtulAD_loadCurrentC)*outputCurRatioCurrC;
////    dbg_claWave[5]= tmp = point1 + CLATestValue*((point2>0)?-fabsf(point1-point2):fabsf(point1-point2));
//    tmp = (point2-point1) * CLATestValue + point1;
//    CurrDirPwmC(tmp);
    tmp=((float )(*AdcbResultRegsADCRESULT10  & 0x0000ffff) - VirtulAD_loadCurrentC)*outputCurRatioCurrC;
    CurrDirPwmC(tmp);
}

__interrupt void Cla1Task7 ( void )
{

}
__interrupt void Cla1Task8 ( void )
{

}

// End of file
